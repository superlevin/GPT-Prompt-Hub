原始提示來自：https://www.dzombak.com/blog/2025/08/getting-good-results-from-claude-code/

# 開發指南

## 理念

### 核心信念

- **漸進式進展勝於一次到位** - 編譯並通過測試的小幅修改
- **從現有程式碼中學習** - 在實作前先研究和規劃
- **務實勝於教條** - 適應專案的實際情況
- **清晰的意圖勝於巧妙的程式碼** - 保持簡單明瞭

### 簡單意味著

- 每個函式/類別單一職責
- 避免過早的抽象化
- 不耍小聰明 - 選擇最簡單直接的解決方案
- 如果你需要解釋它，那它就太複雜了

## 流程

### 1. 規劃與分段

將複雜的工作分解為 3-5 個階段。記錄在 `IMPLEMENTATION_PLAN.md` 中：

```markdown
## 階段 N：[名稱]
**目標**：[具體的交付成果]
**成功標準**：[可測試的結果]
**測試**：[具體的測試案例]
**狀態**：[未開始|進行中|已完成]
```
- 隨著進度更新狀態
- 所有階段完成後刪除該檔案

### 2. 實作流程

1.  **理解** - 研究程式碼庫中現有的模式
2.  **測試** - 先寫測試（紅燈）
3.  **實作** - 用最少的程式碼讓測試通過（綠燈）
4.  **重構** - 在測試通過的情況下進行清理
5.  **提交** - 附上清晰的訊息，並連結到計畫

### 3. 當卡關時（嘗試 3 次後）

**關鍵**：每個問題最多嘗試 3 次，然後停止。

1.  **記錄失敗之處**：
    *   你嘗試了什麼
    *   具體的錯誤訊息
    *   你認為失敗的原因

2.  **研究替代方案**：
    *   尋找 2-3 個類似的實作
    *   注意所使用的不同方法

3.  **質疑基礎**：
    *   這是在正確的抽象層級嗎？
    *   這個問題可以分解成更小的問題嗎？
    *   有沒有一個完全更簡單的方法？

4.  **嘗試不同角度**：
    *   使用不同的函式庫/框架功能？
    *   採用不同的架構模式？
    *   移除抽象而不是增加？

## 技術標準

### 架構原則

- **組合優於繼承** - 使用依賴注入
- **介面優於單例** - 實現可測試性和靈活性
- **明確優於隱含** - 清晰的資料流和依賴關係
- **盡可能測試驅動** - 絕不禁用測試，而是修復它們

### 程式碼品質

- **每次提交都必須**：
    *   成功編譯
    *   通過所有現有測試
    *   包含新功能的測試
    *   遵循專案的格式化/程式碼風格檢查

- **提交前**：
    *   執行格式化工具/程式碼風格檢查工具
    *   自我審查變更
    *   確保提交訊息解釋了「為什麼」

### 錯誤處理

- 快速失敗並提供描述性訊息
- 包含用於除錯的上下文
- 在適當的層級處理錯誤
- 絕不默默地吞下異常

## 決策框架

當存在多種有效方法時，根據以下幾點進行選擇：

1.  **可測試性** - 我能輕易地測試這個嗎？
2.  **可讀性** - 6 個月後還有人能看懂嗎？
3.  **一致性** - 這是否符合專案的模式？
4.  **簡單性** - 這是能運作的最簡單的解決方案嗎？
5.  **可逆性** - 以後要修改有多難？

## 專案整合

### 學習程式碼庫

- 尋找 3 個類似的功能/元件
- 識別常見的模式和慣例
- 盡可能使用相同的函式庫/工具程式
- 遵循現有的測試模式

### 工具

- 使用專案現有的建置系統
- 使用專案的測試框架
- 使用專案的格式化工具/程式碼風格檢查工具設定
- 沒有充分理由不要引入新工具

## 品質關卡

### 完成的定義

- [ ] 測試已編寫並通過
- [ ] 程式碼遵循專案慣例
- [ ] 沒有程式碼風格檢查/格式化警告
- [ ] 提交訊息清晰
- [ ] 實作與計畫相符
- [ ] 沒有沒有問題編號的待辦事項

### 測試指南

- 測試行為，而非實作
- 盡可能每個測試一個斷言
- 清晰的測試名稱，描述情境
- 使用現有的測試工具/輔助函式
- 測試應該是確定性的

## 重要提醒

**絕不**：
- 使用 `--no-verify` 來繞過提交掛鉤
- 禁用測試而不是修復它們
- 提交無法編譯的程式碼
- 做出假設 - 用現有程式碼進行驗證

**永遠**：
- 漸進式地提交可運作的程式碼
- 隨時更新計畫文件
- 從現有的實作中學習
- 嘗試 3 次失敗後停下來重新評估